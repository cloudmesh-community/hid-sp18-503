% status: 100
% chapter: REST


\def\paperstatus{100} % a number from 0-100 indicating your status. 100
                % means completed
\def\paperchapter{REST} % This section is typically a single keyword. from
                   % a small list. Consult with theinstructors about
                   % yours. They typically fill it out once your first
                   % text has been reviewed.
\def\hid{hid-sp18-503} % all hids of the authors of this
                                % paper. The paper must only be in one
                                % authors directory and all other
                                % authors contribute to it in that
                                % directory. That authors hid must be
                                % listed first
\def\volume{9} % the volume of the proceedings in which this paper is to
           % be included

\def\locator{\hid, Volume: \volume, Chapter: \paperchapter, Status: \paperstatus. \newline}

\title{Swagger Service for Openstack Resources}


\author{Arnav Arnav}
\affiliation{%
  \institution{Indiana
  University} \city{Bloomington} \state{IN} \postcode{47408} \country{USA}}
\email{aarnav@iu.edu}


% The default list of authors is too long for headers}
\renewcommand{\shortauthors}{Arnav}


\begin{abstract}
Openstack is one of the most important cloud coputing Infrastructure
as a Service that allows users to setup and manage servers easily. It
provides APIs that help users to manage these services through
command-line and through code. The NIST Big Data Reference
Architecture defines a reference architecture for various objects that
are important in the context of cloud computing. In this project we
aim to build a REST service using these object specifications that
help users complete an openstack deployment easily.
\end{abstract}

\keywords{\locator\ Swagger, Openstack, REST-API, Cloud Computing}


\maketitle

\section{Introduction}
As more and more appliations rely on data generated by their users,
the importnce of cloud computing is rapidly growing due to the need to
process this data and extract useful information.  Openstack is a free
and open source cloud Infrastructure as a Service (IaaS) that allows
users to set up resources such as virtual servers for their
customers. It is one of the most widely deployed cloud infrastructure
and is constantly improving. It provides an openstack python software
development toolkit (sdk) that contains python APIs for openstack
services along with command line tools that allow users to write
python code to remotely perform actions on the openstack
cloud~\cite{hid-sp18-503-openstack-wiki}.

Representational State Transfer (REST) is an architectural standard
for web applications that allows different applications to comunicate
easily. It allows separation of clients and servers and the server
funcionality can be esily changed without affecting the client's
interface to the server. REST is highly scalable and easy to
extend~\cite{hid-sp18-503-REST}. The NIST Big Data Reference
Architecture defines standard properties for objects that that are
important to Big Data ecosystem.

These objects can be easily accessed, and applications using these
objects can comunicate seemlessly with the use of RESTful Applications
that use REST verbs (GET, PUT, POST, UPDATE, DELETE) to manipulate
these objects~\cite{hid-sp18-503-REST}.

We aim to develop a REST service with the help of Swagger - a tool
that converts a yml specification to code - that can be used by other
applications to setup and manage Virtual Machines on openstack.

Doing this requires identification of various objects that are needed
to accomplish such a task. Some of these are images, servers,
keypairs, networks, and subnets. Each of these objects should be
accessible from the REST application, so that they can be updated and
stored as necessary.

\section{NIST Big Data Reference Architecture}
The field of big data is relatively new and there are many definitions
of what big data technologies are. NIST Big Data Public Working Group
(PWG) has been working on formalizing a standard of what consitutes a
Big data ecosystem and what are the components that are needed to
define and setup such an ecosystem. These components have been defined
in the NIST Big Data Reference Architecture (NBDRA) document (Volume
6).  In order to facilitate communication between these components,
there is the need for a comon well defined interface, which has been
defined in the Big Data Ineroperability Framework document (Volume 8)
\cite{hid-sp18-503-BDRA}.

The document identifies what are the different requirements that such
an interface should satisfy. The interfaces should be vendor agnostic,
be reusable in different case specific scenarios and should allow
users to plug in resources as needed. The document investigates the
requirements of different stakeholders in a big data ecosystem and
aims to develop a specification paradigm that fulfils most of these
requirements. The document proposes speciications for various objects
that are required for a big data ecosystem to function properly and
provides examples of these specifications~\cite{hid-sp18-503-BDRA}.

\section{Openstack}

Openstack is an opensource cloud Infrastructure as a Service platform
oiginally built by the colaboration of NASA and Rackspace hosting and
is now maintained by Rackspace. The platform consists of various
components that allow users to contro diverse multi-vendor computing
and storage hardware with the help of web based user interface or
through applications with the hellp of APIs.  The Project was started
in 2010 with the aim of creating an opensource platforms that would
help organizations offer cloud services on standard hardware. The
openstack community has grown to an active collaboration of more than
500 companies and works around a six month cycle with
frequentmilestones~\cite{hid-sp18-503-openstack-wiki}.

\subsection{Openstack Services}
Openstack consists of various services that are responsible for
different operations. Each of htese services are important from a
users viewpoit and are described below:

\begin{itemize}
\item \textbf{Keystone}: Keystone is the identity management system for
openstack. It is responsible for authentication and high level
authorization.  It is this service that generates authentication
tokens a and identifies users with the help of passwords and provides
the need for users to identify themselvs in their
applications. Keystone can be integrated with third party services
such as Lightweight Directory Access Protocol
(LDAP)~\cite{hid-sp18-503-oracle-openstack}
\cite{hid-sp18-503-keystone}.

\item \textbf{Nova}: Nova is the compute service from Openstack, and is
responsible for the management, creation and deletion of virtual
machines with the help of various daemons running on linux.  Nova
allows administrators to choose the hypervisor of their choice while
providing a common API to manage VMs. Nova requires Keystone, Glance
and Neutron to work~\cite{hid-sp18-503-oracle-openstack}
\cite{hid-sp18-503-nova}.

\item \textbf{Glance}: The service responsible for managing and cataloging
images that are uploaded by the users. Glance was built to be the
store for objects required by other services, and the support fot
other objects can be added later~\cite{hid-sp18-503-oracle-openstack}
\cite{hid-sp18-503-glance}.

\item \textbf{Neutron}: Neutron is a networking service provided by openstack.
It is responsible for creating networks between VMs and in addition
includes a firewall, load ballancer, and allows users to create
Virtual Private Networks.  Neutron providesvarious virtual
abstractions such as subnets and routers which work in the same manner
as the physical devices
\cite{hid-sp18-503-oracle-openstack}
\cite{hid-sp18-503-neutron}.

\item \textbf{Cinder}: Cinder is the openstck \emph{block storage as a service}
responsible for managing the external storage including external
volumes and Network File storage (NFS). It is highly availabe, fault
taulerant and is easily recoverable after failures
\cite{hid-sp18-503-cinder}.

\item \textbf{Heat}: Heat is the cloud orchestration layer on opestack. It
is responsible for providing Floating IPs, managing security groups,
servers and many other services. Heat allows all this to be done with
the help of a template file defined by the user that allows Heat to
execute the correct API calls to provision the specied
cloud~\cite{hid-sp18-503-oracle-openstack}
\cite{hid-sp18-503-heat}.

\item \textbf{Horizon}: Horizon is the Graphical User Interface (GUI) dashboard
that allows users to conect to openstack and and access openstack
services using their web browsers~\cite{hid-sp18-503-oracle-openstack}
\cite{hid-sp18-503-horizon}.

Openstack provides differnet clients for each of these services that
can be installed individually as needed. They provide a common unified
API with the help of the openstack SDK that allows users to access
most of thse sevices. Some of the services do not have complete
functionality in the openstack SDK, which will be included in the near
future~\cite{hid-sp18-503-openstack-sdk}.
\end{itemize}

\subsection{Openstack SDK}
The openstack SDK is a client library that alows users, and
applications to interact with openstack services. It aims at providing
all of the functionality that is provided by the services along with
proper documentation and examples. The SDK provides an abstraction
layer that abstracts away the complxities of the differences in
specific openstack deployments, while also providing service specific
tools when complex functions are to be
performed~\cite{hid-sp18-503-openstack-sdk-history}.

The openstack SDK was built initially from three different libraries-
shade, os-client-config and python-openstacksdk. Shade was initially a
part of the openstack nodepool project with some of its code written
inside the Ansible openstack module. It was later consolidated and
moved into \emph{openstack.cloud} module. The philosophy from nodepool
allows the users to change clouds they want to connect to in their
code, without worrying much about the differences. The
os-client-config was a library written to gather the configuration
information from different deployments in a consistent manner. This
was moved to \emph{openstack.config} module which now reads the
configuration from the \emph{clouds.yaml} file (if available). The
python-openstacksdk was a library that exposed the API to
developers~\cite{hid-sp18-503-openstack-sdk-history}.

\subsubsection{Installing the SDK}
The sdk can be eaily installed from the Python Pagkage Index (PyPI)
using the command:

\begin{verbatim}
pip install openstacksdk
\end{verbatim}

The sdks for the individual services, if needed can be installed
similarly using pip as follows:

\begin{verbatim}
pip install python-PROJECTclient
\end{verbatim}

where PROJECT should be replaced with the name of the partcular
service (such as nova)

To use the openstack sdk, and communicate with a cloud, first a
connection must be created to the cloud. This can be done either by
using a clouds.yaml file or by explicitly passing the variables to
the \emph{openstack.connect\(\)} method. Once a connection is made,
the application can communicate to different services using the
openstack sdk. These services are included in the modules named based
on the service functionality for simplicity for users not familiar
with openstack terminology. The neutron servce is abstracted in the
module \emph{openstack.network}, the nova service
to \emph{openstack.compute} module, the keystone service
to \emph{openstack.identity} module and so on.

\subsection{Devstack}
Devstack is a single node openstack installation which is a part of
the openstack Quality Assurance (QA) project, an aims to provid tools
required to install openstack from the source code to facilitate
development and testing. Devstack provides a quick and easy way to
install openstack for testing purposes, however it is not intended to
be an openstack installer
\cite{hid-sp18-503-devstack}.

Devstack requires a minimum of of 8GB or RAM, two processor cores, an
ethernet and internet access, an a supported linux version. Once
Devstack has been installed, it can be used to show and test how a new
functionality wroks by using the Horizon interface and through command
line APIs~\cite{hid-sp18-503-devstack}.

It is suggested that devstack be setup on a virtual machine, and not
natively on a developer's machine. Once a virtual machine that
satisfies the requirements is set up, a new non-root user needs to be
created that has sudo privileges.  Following this the devstack
repository can be cloned from GitHub. Executing the
\emph{stack.sh} script, installs openstack services with minimal
configuration~\cite{hid-sp18-503-devstack-setup}.

\subsection{Openstack Container Service}
In addition to providing servics to users for using virtual machines
and virtual machine clusters, the Openstack Container Team developed
an API called \emph{magnum} that makes container orchestration
availale to users as an openstack resource. MAgnum cluster
orchestration engine uses Heat orchestration that uses an operating
system image cintaining docker and kubernetes and runs that image on a
Virtual machine with the help of Nova. It uses Neutron to network
kubernetes containers, uses Cinder to provide volumes for containers
and allows users to chooese between Kubernetes, Docker and Apache
Mesos as the cluster backend
technology~\cite{hid-sp18-503-magnum-wiki}.

Magnum service consists of two parts, the magnum REST service, and the
magnum-conductor. The REST server is horizontally scalable and can
handle many requests at a time, while the conductor process is only
single threaded at this time. All requests are stored in a message
queue before magnum-conductor process can work on
them~\cite{hid-sp18-503-magnum-intro}.  All calls to the magnum
service need to be authenticated with Keystone, and users can only see
containers that arestarted by them. This provides an additional layer
of security for the users. Magnum is intended for use by cloud
providers who want to gicve users the option to create self service
continers and container clusters just as easily as openstack Virtual
Machines~\cite{hid-sp18-503-magnum-wiki}.

The magnum comandline and python clients can be easily installed from
Python Package Index (PyPI) using pip by running the command:
\begin{verbatim}
pip install python-magnumclient
\end{verbatim}
The magnum-client is not included in the python openstack SDK at this
point and it has to be installed separately.

\section{Chameleon Cloud}
Chameleon cloud is an experimental test bed for the FutureCloud
project that is funded by NSF. Chameleon clou offers researchers
across the US 5 PB of storage and 550 nodes physically separated
across two different locations, the Texas Advanced Computing Center
and the University of Chicago (UC) and encourages users to use lesser
resources fr prototyping, automate their deployment and try the
experiment on a larger cale to get more powerful results and hopefully
publish their research
\cite{hid-sp18-503-handbook}.

Chameleon cloud comprises of a set of 12 Standsrd Cloud Units, each
comprising of 42 compute nodes, 4 storage nodes with 128TB local
storage and is connected to a network switch. Chameleon cloud is also
equipped with numerous other hardware tyes to allow
experimentation. The two locations TACC and UC are connected through a
high speed internet connection~\cite{hid-sp18-503-handbook}.

\section{Swagger}
Swagger is an opensource set of tools for creatin APIs from openAPI
specifications. Swagger project was initially owned by SmartBear and
later donated to the linx foundation marking the start of the openAPI
standard. Swagger follows an API first philosophy and simplifies the
process of writing APIs for new and existing applications.  The
Swagger toolkit consists of various applications that include Swagger
Codegen, Swagger Core, Swagger UI, Swagger Editor and Swagger
Hub. While Swagger Codegen helps to build code stubs from the openAPI
specificaton in many languages, the Swagger Inspector helps users to
build openAPI Specifications from any API in the browser.  The swagger
community is separated from the openAPI comunity and focuses on
building tools that can be used by the developers to build
applications from the openAPI
specification~\cite{hid-sp18-503-swagger}.

The openAPI specification is a standard and simple way to define an
API that allows users to understand the functionality without having
to read throughthe documentation od the entire
code~\cite{hid-sp18-503-swagger-openapi}.

The openAPI standard allows specifications to be written in both yaml
and JSON format. The API may include many differnet objects that can
be defined in one file or in separate linked
files~\cite{hid-sp18-503-swagger-openapi}.

\section{Approach}

The project uses all the technological concepts defined above. It
comprses of a REST API developed from the openAPI specification that
was used to generate code using \emph{swager-codegen}. This allowed us
to easily make updates and changes to the yaml structure without
having to manually change a lot of the code.

The project in its entirity comprises of three parties - an openstack
cloud (\emph{chameleon cloud} in this case), a server running the REST
API (\emph{swagger server}) and a client. The client issues API calls
to the endpoints on the swagger server, which in turn uses the
openstack sdk to communicate to the cloud. The specification of the
objects that is defined in the \emph{devstack.yml} swagger
specification file drives how these API calls are made, and thus is
the most important part of the process.

\subsection{Object Definitions}
The following are the objects that are used in this project. These
objects are inspired by the objects defined in the Nist Big Data
Reference Architecture NIST (BDRA) document:

\begin{itemize}
\item \textbf{Flavor}: Flavors identify the different types of hadrdware
available to the openstack users. A user can select a flavor based on
their needs and the requirements o the image. The flavors include in
their definition the RAM size, disk size, the number of virtual CPUs
and the available swap memory, and are identified using a unique ID
and a name.

\item \textbf{Image}: An Image defines what types of operating systems are
availabe to be used to create a virtual machine on openstack. Each of
the images can have different minimum requirements that are needed to
install the operating system and they must be included in the
object. 

\item \textbf{Keypair}: A keypair defines a set of RSA keys that are
generated by openstack to allow usere to correctly identify themselves
and to log into the servers. It has two parts, a public key and a
provate key and is identified with the help of a user defined
name. 

\item \textbf{Server}: A server is another name for a Virtual Machine
running on the openstack cloud. To define a server we must define the
name of the server, the flavor and the image to be used, the secirity
groups and networks that are needed for the server and a keypair that
will be used to connect to the server in the future, along with a
floating IP address. 
\item \textbf{Networks}: Openstack allows users to set up their own
networks for their virtual machines, and alows them to create new VMs
that use these networks. Networks can be internal or external and can
have subnets created by the user.

\item \textbf{Subnet}: Subnets allow users to identify and separate
different parts of their openstack networks. A subnet object should
contain a list of DNS servers and shoud identify whether it has a DHCP
server or not.  A minimal definition of the subnet oject is given in
the appendix.
\end{itemize}

\subsection{Available Endpoints}
To run the application move into the project directory and provide
correct credetnials in the clouds.yml file, thenrun the following code
in the terminal:
\begin{verbatim}
make make run
\end{verbatim}
The \emph{make} command downloads \emph{swagger-codegen} jarfile, runs
swagger-codegen to generate the python stub for the project, and
copies the \emph{clouds.yml} and \emph{default\_controler.py} files at
the right place. The \emph{make run} command starts the server at
localhost on port 8080.

The objects defined for this project can be accessed through REST API,
as follows:
\begin{itemize}
\item \textbf{GET:} /cloudmesh/openstack/flavors: returns a list of all
flavors that are available. It uses the openstack.compute module to
perform this function.

\item \textbf{GET:} /cloudmesh/openstack/images: returns a list of all
available images. It again uses the openstack.compute module to
perform this function.

\item \textbf{GET:} /cloudmesh/openstack/image/{name}: returns the image
with the specified name if there exists one.

\item \textbf{GET:} /cloudmesh/openstack/networks: returns a list of all
available networks. It uses openstack.network module for this API
call, which communicates to the openstack neutron service.

\item \textbf{GET:} /cloudmesh/openstack/networks/subnets: returns a list of
all subnets available to the user.

\item \textbf{GET:} /cloudmesh/openstack/keypairs: returns a list of keypairs
that can be used by a user. The openstack.identity modulewas used for
this function which in turn communicates to the keystone service.

\item \textbf{GET:} /cloudmesh/openstack/servers: returns a list of servers
(Virtual Machines) that are available on the openstack cloud

\item \textbf{POST:} /cloudmesh/openstack/server/start: start the server with
the given name, if the server (Virtual Machine) is present on the
cloud.

\item \textbf{POST:} /cloudmesh/openstack/server/stop: stop the server with
the given name, if the server (Virtual Machine) is present on the
cloud

\item \textbf{POST:} /cloudmesh/openstack/keypair/create: create a new keypair
 for the nova service with the name specified in the request body

\item \textbf{POST:} /cloudmesh/openstack/network/create: create a new network
 with the name specified in the request body

\item \textbf{DELETE:} /cloudmesh/openstack/network/delete: delete the network
 with the name specified in the request body.

\item \textbf{DELETE:} /cloudmesh/openstack/keypair/delete: delete the nova
keypair with the name specified in the request body.

\end{itemize}

The project uses a Dockerfile that build an image for the
service, which builds on top of the python3 image and installs all requirements
Docker containers are lightweight and allow us to reproduce our project on a
new machine without worrying about the specific environments and dependencies.

\subsection{Significance}
The Openstack services usuallly provide various endoints that support
various REST API calls, but using these endpoints requires knowldge of
openstack terminology and the knowledge of how these APIs should be
used which can be complicated. Further there exist various vendors who
provide openstack clouds as a service, and openstack allows
administrators to make changes in how they want to deploy their cloud
services, and thus the usage of endpoints for these services may
differ across different openstack clouds. In such situations an
application like ours provdes another layer of abstraction to the API
and can allow users to use the same minimal API to manage various
diffeent deployments of openstack.

Most cloud providers do not enforce user privilleges on the kinds of
applications that can be run by a user in a VM. Adding another layer
of abstraction can allow administrators to control, for instance,
which users can install which softwares on these VMs, in an
organizational setting where these softwares may be lisenced and
expensive.

\section{Conclusion}
Openstack is an open source cloud IaaS and provides the openstack SDK
that allows applications and users to commmunicate to the
cloud. Swagger codegen is a tool that alllows quick development of
software with the help of a yaml file that is written following the
openAPI standard. Using the swagger spcification for some of the
objects required for big data ecosystem, applications can be easily
developed that use these objects. There exist various definitions of
these objects, but it is important to develop an open standard that
must be followed for consistency across applications.

\section{Improvements}
We define a basic application that uses the openAPI swagger
specification for some of the objects that are required in a cloud
based ecoystem. The project can be extended to include various other
cloud services that are commonly used, while maintaining the same REST
API.

The project API can be extended to provide services and functions that
can be used to perform various actions, such as a Machine Learning API
uses a trained model to allow users to autogenerate image captions
\cite{hid-sp18-503-image-cap}.

\bibliographystyle{ACM-Reference-Format}
\bibliography{report} 

%% \appendix
%% \section{Oject Speifications}
%% The swagger specifications for the objects used for the project are listed
%% in this section

%% \begin{itemize}
%% \item \textbf{Flavor}:
%% \begin{verbatim}
%% Flavor:
%%     type: ``object''
%%     required:
%%       - ``name''
%%     properties:
%%       vcpus:
%%         type: ``string''
%%       name:
%%         type: ``string''
%%       id:
%%         type: ``string''
%%       swap:
%%         type: ``string''
%%       ram:
%%         type: ``string''
%%       disk:
%%         type: ``string''

%% \end{verbatim}

%% \item \textbf{Image}
%% \begin{verbatim}
%% Image:
%%     type:
%%       ``object''
%%     required:
%%       - ``name''
%%     properties:
%%       name:
%%         type: ``string''
%%       id:
%%         type: ``string''
%%       min_ram:
%%         type: ``string''
%%       min_disk:
%%         type: ``string''
%%       status:
%%         type: ``string''
%%       updated_at:
%%         type: ``string''
%%       size:
%%         type: ``string''
%% \end{verbatim}

%% \item \textbf{Keypair}
%% \begin{verbatim}
%% Keypair:
%%     type: ``object''
%%     required:
%%       - ``name''
%%     properties:
%%       name:
%%         type: ``string''
%%       public_key:
%%         type: ``string''
%%       private_key:
%%         type: ``string''
%% \end{verbatim}

%% \item \textbf{Server}
%% \begin{verbatim}
%% Server:
%%     type: ``object''
%%     required:
%%       - ``name''
%%       - ``flavour''
%%       - ``image''
%%     properties:
%%       name:
%%         type: ``string''
%%       flavour_id:
%%         type: ``string''
%%       floatingIP:
%%         type: ``string''
%%       image_id:
%%         type: ``string''
%%       status:
%%         type: ``string''
%%       created_at:
%%         type: ``string''
%%       security_groups:
%%         type: ``array''
%%         items:
%%           type: ``string''
%%       keypair:
%%         type: ``string''
%%       network:
%%         type: ``string''
%% \end{verbatim}

%% \item \textbf{Network}
%% \begin{verbatim}
%% Network:
%%     type: ``object''
%%     required:
%%       - ``id''
%%     properties:
%%       id:
%%         type: ``string''
%%       subnets:
%%         type: ``array''
%%         items:
%%           type: ``string''
%%       status:
%%         type: ``string''
%%       mtu:
%%         type: ``string''
%%       is_router_external:
%%         type: ``string''

%% \end{verbatim}

%% \item \textbf{Subnet}
%% \begin{verbatim}
%% Subnet:
%%     type: ``object''
%%     required:
%%       - ``id''
%%     properties:
%%       id:
%%         type ``string''
%%       dns_nameservers:
%%         type: ``array''
%%         items:
%%           type: ``string''

%%       project_id:
%%         type: ``string''
%%       name:
%%         type: ``string''
%%       is_dhcp_enabled:
%%         type: ``string''
%% \end{verbatim}

%% \end{itemize}
